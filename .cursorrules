# Cursor Rules for Spawn App iOS SwiftUI

## Singleton Pattern Rules

### Do NOT use singletons as EnvironmentObjects
- **Rule**: Never instantiate singleton classes when passing them as environment objects
- **Correct**: Access singletons via their `.shared` property
- **Incorrect**: Creating new instances with `ClassName()` when a singleton exists

#### Examples:
```swift
// ❌ WRONG - Don't create new instances of singletons
.environmentObject(UserAuthViewModel())
.environmentObject(NotificationService())

// ✅ CORRECT - Use the shared instance
.environmentObject(UserAuthViewModel.shared)
.environmentObject(NotificationService.shared)
```

#### Rationale:
- Singletons maintain global state that should be consistent across the app
- Creating new instances breaks the singleton pattern and can cause state inconsistencies
- Using `.shared` ensures all parts of the app work with the same instance

#### Common singleton classes in this project:
- `UserAuthViewModel.shared`
- `NotificationService.shared`
- `KeychainService.shared`

## Figma-to-Code Plugin Output Rules

### Understanding Design Intent, Not Implementation
- **Rule**: Use Figma-to-code output ONLY to understand the visual design and layout intent
- **Never**: Copy the generated code directly into the project
- **Always**: Translate the design using the project's existing styling system

#### Examples:
```swift
// ❌ WRONG - Direct copy from Figma plugin
Text("Save")
  .font(Font.custom("Onest", size: 20).weight(.semibold))
  .foregroundColor(.white)
  .padding(16)
  .frame(width: 290, height: 56)
  .background(Color(red: 0.42, green: 0.51, blue: 0.98))
  .cornerRadius(16)

// ✅ CORRECT - Use project's styling system
Text("Save")
  .font(.onestSemiBold(size: 20))
  .foregroundColor(.white)
  .padding(.horizontal, 16)
  .padding(.vertical, 12)
  .frame(maxWidth: .infinity)
  .background(figmaBlue)
  .cornerRadius(universalRectangleCornerRadius)
```

#### What to Extract from Figma Output:
1. **Layout Structure**: Understand the hierarchy of VStacks, HStacks, and ZStacks
2. **Component Relationships**: See how elements are positioned relative to each other
3. **Visual Hierarchy**: Identify primary, secondary, and accent elements
4. **Spacing Patterns**: Observe the general spacing between elements
5. **Color Roles**: Understand which colors are used for what purposes

#### What NOT to Copy:
1. **Hardcoded Colors**: Use predefined colors from `Constants.swift`
2. **Hardcoded Fonts**: Use the Onest font extensions (`.onestSemiBold()`, etc.)
3. **Exact Pixel Values**: Use consistent spacing and sizing patterns
4. **Complex Offset/Frame Calculations**: Simplify using standard layout patterns
5. **Excessive Nesting**: Optimize the view hierarchy for maintainability

#### Translation Guidelines:
- Replace `Color(red: X, green: Y, blue: Z)` with appropriate constant colors
- Replace `Font.custom("Onest", size: X)` with `.onestSemiBold(size: X)`
- Replace exact `.frame(width: X, height: Y)` with responsive sizing
- Replace complex `.offset()` chains with proper layout containers
- Replace hardcoded spacing with consistent padding patterns

### Additional SwiftUI Best Practices

#### Environment Objects
- Use `@EnvironmentObject` for shared state that needs to be accessed by multiple views
- Pass environment objects at the highest level possible in the view hierarchy
- Always use existing singleton instances rather than creating new ones

#### State Management
- Prefer `@StateObject` for view-owned objects
- Use `@ObservedObject` for objects passed down from parent views
- Use `@EnvironmentObject` for globally shared objects

## DTO Property Validation Rules

### Always Verify DTO Properties Before Access
- **Rule**: Check DTO structure and available properties before accessing them in code
- **Never**: Assume properties exist on DTOs without verification
- **Always**: Inspect the DTO definition first, then access only existing properties

#### Examples:
```swift
// ❌ WRONG - Accessing properties without verification
Text(activity.title ?? "Activity")  // CalendarActivityDTO doesn't have 'title'
Text(activity.description ?? "")    // FullFeedActivityDTO doesn't have 'description'

// ✅ CORRECT - Verify DTO structure first
// For CalendarActivityDTO: only has id, date, icon, colorHexCode, activityId
// For FullFeedActivityDTO: has title, note (not description), startTime, endTime, etc.
Text(fullActivity.title ?? "Activity")  // Use full activity after fetching
Text(fullActivity.note ?? "")           // Use 'note' instead of 'description'
```

#### Common DTO Property Mappings:
- `CalendarActivityDTO`: Basic calendar display info (id, date, icon, colorHexCode, activityId)
- `FullFeedActivityDTO`: Complete activity details (title, note, startTime, endTime, location, etc.)
- `BaseUserDTO`: User information (id, username, name, profilePictureURL, etc.)
- `ProfileActivityDTO`: Profile-specific activity data

#### Best Practices:
1. **Read the DTO definition** in `Models/DTOs/` before accessing properties
2. **Use code completion** to see available properties
3. **Fetch full DTOs** when you need complete information (e.g., use activityId from CalendarActivityDTO to fetch FullFeedActivityDTO)
4. **Check property names** carefully (e.g., 'note' vs 'description', 'name' vs 'title')
5. **Handle optional properties** appropriately with nil coalescing or optional binding

#### When to Fetch Additional Data:
- If you have a `CalendarActivityDTO` but need title/description, fetch the full activity using `activityId`
- If you have a `BaseUserDTO` but need detailed profile info, fetch `UserProfileInfoDTO`
- If you have activity ID but need participants, fetch `FullFeedActivityDTO` 

## Navigation Back Button Rules

### Avoid Duplicate Back Buttons
- **Rule**: Never create custom back buttons in views that are presented via NavigationLink
- **Problem**: Views presented via NavigationLink automatically get a system back button, creating duplicates
- **Solution**: Use system navigation or present differently (sheet, fullScreenCover)

#### Examples:
```swift
// ❌ WRONG - Custom back button in NavigationLink destination
struct DetailView: View {
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        VStack {
            HStack {
                Button(action: { dismiss() }) {
                    Image(systemName: "chevron.left")
                }
                Spacer()
                Text("Detail Title")
                Spacer()
            }
            // ... rest of content
        }
    }
}

// ✅ CORRECT - Let system handle navigation
struct DetailView: View {
    var body: some View {
        VStack {
            // ... content without custom back button
        }
        .navigationTitle("Detail Title")
        .navigationBarTitleDisplayMode(.inline)
    }
}
```

#### Solutions for Different Presentation Types:
1. **NavigationLink destinations**: Remove custom back buttons, use `.navigationTitle()` and `.navigationBarTitleDisplayMode()`
2. **Sheets**: Keep custom close buttons as they don't have system navigation
3. **FullScreenCover**: Keep custom close buttons as they don't have system navigation

#### When Custom Back Buttons Are Acceptable:
- Modal presentations (sheet, fullScreenCover)
- Custom navigation implementations
- Views that need special back button behavior (alerts, confirmations)

#### Common Fixes:
- Remove custom back button HStacks from NavigationLink destinations
- Replace with `.navigationTitle()` and `.navigationBarTitleDisplayMode()`
- Keep custom styling for modal presentations only